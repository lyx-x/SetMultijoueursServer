%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[paper=a4, french]{scrartcl} % A4 paper and 11pt font size

\usepackage[utf8]{inputenc} 
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage{fourier} % Use the Adobe Utopia font for the document - comment this line to return to the LaTeX default
\usepackage[francais]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage{colortbl}

\definecolor{bg}{RGB}{235,235,235}

\usepackage{sectsty} % Allows customizing section commands
\allsectionsfont{\centering \normalfont\scshape} % Make all sections centered, the default font and small caps

\usepackage{fancyhdr} % Custom headers and footers
\sectionfont{\normalfont\scshape} % Make all sections centered, the default font and small caps
\subsectionfont{\normalfont\scshape}
\subsubsectionfont{\normalfont\scshape}

\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers
\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer
\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

\setlength\parindent{0pt} % Removes all indentation from paragraphs - comment this line for an assignment with lots of text
\newcommand{\class}[1]{\colorbox{bg}{\textcolor{red}{\usefont{OT1}{cmtt}{m}{n}#1}}}

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height

\title{	
\normalfont \normalsize 
\textsc{Ecole Polytechnique} \\ [25pt] % Your university, school and/or department name(s)
\horrule{0.5pt} \\[0.5cm] % Thin top horizontal rule
\huge Set multijoueurs \\ % The assignment title
\horrule{2pt} \\[0.5cm] % Thick bottom horizontal rule
}

\author{Zhixing CAO, Yuxiang LI} % Your name

\date{\normalsize\today} % Today's date or a custom date

\begin{document}

\setlength\parindent{12pt}

\maketitle % Print the title

% + - = ! / ( ) [ ] < > | ' :

%----------------------------------------------------------------------------------------
%	Introduction
%----------------------------------------------------------------------------------------

\section{Introduction}

Ce projet consiste à développer une application Android en appliquant la programmation concurrente et à réaliser une communication serveur-client. Cette application permet de jouer un jeu appelé \textbf{Set} soit en mode solo, soit en multijoueur. On présentera d'abord la règle du jeu et leur correspondance en terme de Java ou Android. On expliquera ensuite plus en détail la réalisation de tous les modules nécessaires à ce jeu, on verra en quoi la programmation multithread permet d'avoir une meilleure performance de l'application.

%----------------------------------------------------------------------------------------
%	Protocole
%----------------------------------------------------------------------------------------

\section{Principe du jeu et protocole de communication }

%-------------------------------------
\subsection{Comment jouer le jeu ?}

\subsubsection{Présentation}
Le jeu \textbf{Set} est un jeu de cartes constitué de 81 cartes toutes différentes qui se distinguent selon 4 caractéristiques : la couleur, la forme, le type de remplissage et le nombre d'objets. Le but du jeu est de trouver un ensemble de 3 cartes qui ont des caractéristiques soit toutes les trois identiques, soit toutes les trois différentes. Le jeu peut se jouer à un ou à plusieurs, à chaque tour, on affiche 12 cartes sur l'écran, et le premier joueur qui trouve un bon set de 3 cartes gagne et ces 3 cartes vont être remplacés par 3 autres. S'il n'y a pas de bon set parmi ces 12 cartes, on en rajoute 3 supplémentaires en supposant qu'il y ait toujours un set parmi elles.

\subsubsection{Choix des cartes}
Le choix des cartes se fait l'un après l'autre, les cartes choisies sont entourées du bleu, cliquer sur la carte déjà choisie permet de l'enveler du set. Une fois qu'on a 3 cartes, on soumet directement la solution.

\subsubsection{Score et pénalité}
En mode solo, le set est vérifié sur place, tout set correct sera coloré en vert et incorrect en rouge. La couleur disparaitra après une petite durée. Une fois que le set est jugé, on ne peut plus le toucher avant la disparition de la couleur. Le set correct sera ensuite remplacé par 3 nouvelles cartes et il rapportera 10 points. On enlève 2 points pour un faux set.
 
%------------------------------------------------
\subsection{Comment communiquer avec le serveur ?}

\subsubsection{Serveur}
Le serveur gère tout le déroulement du jeu en mode multijoueur de la façon suivante : 
\begin{itemize}
\item Initialiser le jeu : initialiser les cartes
\item Changer les cartes 
\item Attribuer les points suivant l'ordre d'arrivée du message : le deuxième ne reçoit rien
\item Débloquer le jeu si tous les joueurs sont bloqués
\item Faire sortir un joueur après une longue durée de silence
\end{itemize}
	
\subsubsection{Client}
Le côté client est plus simple. 
\begin{itemize}
\item Traiter les messages reçus : changer les cartes, renouveller le score ou débloquer le jeu
\item Vérifier le set comme dans le mode solo
\item Se bloquer pour un faux set et soumettre le résultat pour un bon
\item Quitter le jeu en prévenant le serveur
\end{itemize}
	
%----------------------------------------------------------------------------------------
%	Description du projet
%----------------------------------------------------------------------------------------

\section{Du côté de Java}
%-------------------------------------

\subsection{Android}

La partie Android se divise principalement en 2 parties : la class \class{CardView} correspondant à View de \textbf{MVC} et \class{MainActivity} jouant à la fois le rôle de Model et de Controller.

\begin{itemize}
\item \class{CardView} et \class{Card}

Bien qu'on n'ait que 81 cartes, on a choisi de les modéliser avec une classe au lieu d'un entier, ce choix permet d'avoir une plus grande liberté et clarté du code, la méthode \class{hashCode} et le constructeur permettent de créer une bijection entre les deux espaces d'états pour faciliter la communication. Tandis que \class{CardView}, en héritant la classe \class{View}, gère l'affichage des cartes suivant les paramètres (membres de la classe) : carte de score, carte correcte, carte choisie, etc. En conséquence, les \class{OnClickListener} sont directement associés à ces \class{CardView}, ce qui évite de compliquer le traitement des événements.

\item \class{MainActivity}

Cette classe se charge d'interagir avec l'utilisateur et de distribuer le travail au sein de l'application (communication Socket, calcul, affichage). Il permet de contrôler le score, de changer les couleurs des \class{CardView} et de remplacer les cartes. Plusieurs classes du type \class{Thread} et \class{Runnable} sont définies dans cette partie en rendant l'application multi-tâches.

\end{itemize}
 
%-------------------------------------
\subsection{Serveur}

Le code du serveur est réalisé en-dehors de l'application Android dans une nouvelle classe : \class{Server}. Cette classe gère la création d'un nouveau \class{Thread} pour chaque nouveau joueur, l'attribution du point, etc.. Les différents messages sont listés ci-dessous : 

\begin{itemize}
\item (Serveur) Modifier les cartes : V{\textvisiblespace}$pos_1${\textvisiblespace}$card_1${\textvisiblespace }$pos_2${\textvisiblespace}$card_2${\textvisiblespace}$pos_3${\textvisiblespace}$card_3$
\item (Serveur) Incrémenter le score : S{\textvisiblespace}$card_1${\textvisiblespace}$card_2${\textvisiblespace}$card_3$
\item (Serveur) Faire sortir le joueur : E
\item (Client) Demander le redémarrage : R
\item (Client) Informer sur l'état de blocage : F
\item (Client) Soumettre le résultat : S{\textvisiblespace}$pos_1${\textvisiblespace}$card_1${\textvisiblespace }$pos_2${\textvisiblespace}$card_2${\textvisiblespace}$pos_3${\textvisiblespace}$card_3$
\item (Client) Quitter le jeu : E
\end{itemize}


%----------------------------------------------------------------------------------------
%	Détail de réalisation
%----------------------------------------------------------------------------------------

\section{Réalisation et détails techniques}

%-------------------------------------

\subsection{Mélange des cartes}
Pour créer le tas de carte, on tire aléatoirement 81 entiers entre 0 et 99 à qui on associe les 81 cartes. Et puis, en triant toutes ces paires d'entiers par leur valeur aléatoire, on obtient une liste des cartes mélangées. 
	
\subsection{Vérification d'un bon set et \class{Class<?>}}
La vérification d'un set nécessite de regarder tous les 4 membres de la cartes. Une vérification manuelle est possible, mais cette méthode n'est pas facilement reproductible. On a utilisé ici le mécanisme de réflexion qui permet de trouver tous les membres d'une classe dynamiquement par la méthode \class{getDeclaredFields}.

\subsection{Handler}
L'application Android limite l'accès à l'interface graphique, toutes les modifications se font uniquement dans le Thread UI. On utilise donc le mécanisme de Looper / Handler pour gérer toutes les demandes de modifications venant d'autre thread.

\subsection{File d'attente et \class{ExecutorService}}
Le traitement de soumission est quelques choses d'important, car il faut s'assurer que la deuxième soumission n'a pas de points. Pour cela, on utilise une file de travail pour traiter toutes les soumissions. Il existe dans Java une classe \class{ExecutorService} pour créer un nombre limité de thread de travail, on a utilisé \class{Executors.newSingleThreadExecutor} pour que les soumissions soient traitées l'une après l'autre.

\subsection{\class{Callable<T>} et \class{Future<T>}}
Le résultat d'analyse du résultat doit être vu par le reste du programme. Générallement on utilise une variable globale pour faire sortir une valeur d'un thread. Mais une variable ne suffit pas, car nous avons beaucoup de soumissions à traiter et on ne sais pas quand est-ce que la valeur précédente est lue. En alternative, Java propose une interface \class{Callable<T>} pour retourner une valeur de type \class{Future<T>}. Cette valeur sera ensuite utilisée pour renvoyer le message au client.

\subsection{Thread retardé et en boucle}
Certaines tâches demandent une exécution en boucle comme l'affiche du temps et la réception du message, ou une exécution retardée comme la coloration de la carte. Pour ne pas ralentir toute l'application, ce genre de travail ne peut pas s'exécuter dans le thread principal, on a écrit pour cela deux nouvelles classes ayant pour membre un object implémentant \class{Runnable} et un Timer pour effectuer le travial qu'on veut à un moment précis.

\subsection{Thread Client}
Afin de communiquer avec le client en temps réel, la communication doit se faire dans un thread séparé. On créera donc un nouveau thread à chaque fois qu'il y a un nouveau joueur et ajouter le thread dans une liste pour suivre son état plus tard.

\subsection{Débloquer les joueurs}
Une fois qu'un faux set est trouvé, le joueur est bloqué. Cependant comme ce jeu n'est pas si facile, on se trouve souvent dans une situation où tous les joueurs sont bloqués. Pour continuer le jeu, le serveur a un thread qui vérifie en boucle l'état de chaque joueur (à travers une liste de thread mentionnée plus haut). Si tous les joueurs sont bloqués, il leur envoye un signal de déblocage. L'état de chaque joueur s'actualise avec l'arrivée de son message.

\subsection{Faire sortir un joueur}
En pratique, le jeu peut être intérrompu par beaucoup de choses. Le serveur possède un autre thread qui met les joueurs en inactifs toutes les quelques minutes et au bout d'encore quelques minutes, si le joueur n'a rien envoyé entre temps, un message lui sera envoyé et une fois que le message est reçu par le client, il se met ensuite en mode solo et quitte le jeu.

\subsection{Nouveau tour}
Arpès avoir épuisé toutes les 81 cartes, on réinitialise toutes les cartes, mais on enlève automatiquement de ce nouveau tas toutes les cartes actuellement présentes sur l'écran pour ne pas avoir deux cartes identiques.


%----------------------------------------------------------------------------------------
%	Conclusion
%----------------------------------------------------------------------------------------

\section{Conclusion}

%-------------------------------------

A travers ce projet, on s'est familiarisé avec l'application Android et la programmation concurrente. On a connu de différents techniques de Java comme le mécanisme de réflexion. La partie graphique demende cependant une amélioration pour que cette application soit vraiment utilisable. Un tableau de score et l'ajout du mode de duel sont aussi envisageables.

%----------------------------------------------------------------------------------------


\end{document}